# HashTable 散列表

## 基本想法/一般想法
- 给定一表，表的大小为`TableSize`，每个关键字映射到表的0~TableSize-1范围内的某个值，并存放在适当的单元（内存中分好的区），其中映射称之为散列函数。
- 散列函数要求足够简单，并确保任意两个键不映射到同一值（若映射到同一值则称之为“冲突”）。但因为数据范围有限，完全避免不冲突不可能。
- 故需要确定一函数以处理冲突和确定散列表大小问题。

## 冲突处理
1. 对于任何的散列表，key所对应的hash值需要限制在表的大小之内（即 $hash=getHash(x)$ mod $tablesize$）。
2. 故无论多大的表，都会发生冲突。

## 冲突处理方式

### 1. 分离链接表
- 即使用数组和链表的组合来实现，数组为链表类型数组，其每个单元的元素为链表。
- 通过hash值定位在数组中的位置，再将其放入至相应位置所拥有的链表中（hash值通过`int hash=obj.hashcode(); hash %=arrayLength; return hash;`方式获得）。
  - Tips: 因为受限于表的范围，需要将每个从对象获得的哈希值均映射到表中，故使用哈希值与表长之间求余数的方法以实现。（**求余的特性：结果的范围限制于除数**）。

### 2. 线性探测法（非链式）
- 用函数定义为：$h(x)=hash(x)+f(i)$ , 其中$f(i)$ 为冲突解决方法。
	- 对于线性探测法，$f(i)=i$ ，其中 $i$ 为探测次数。
- 在发生冲突时，则线性查找下一个空闲地址，若有则插入。此方法会在表足够大时会导致计算时间加长，即使一定会有空闲的位置。
- 且在表相对较空的情况下，也会出现数据堆积在一块的现象。

### 3. 平方探测法（非链式）
- 用函数定义为：$h(x)=hash(x)+f(i)$，其中$f(i)$ 为冲突解决方法（与线性相似）。
	- 对于平方探测，$f(i)=i^2$ ，其中 $i$ 为探测次数。
- 可以使用递归的方式（自己定义自己，前者定义后者）重新定义$f(i)=i^2$ ：$f(i)=f(i-1)+2i-1$。
- 平方探测法和线性探测法一样，到达一定数量后会出现数据堆积在一起的情况。

### 4. 双散列
- 用函数定义依然为：$h(x)=hash(x)+f(i)$，其中$f(i)$ 为冲突解决方法（与前两者相似）
	- 对于双散列，$f(i)=i*hash_2(x)$ ，将出现冲突的次数和第二个散列函数相乘，互相影响。




