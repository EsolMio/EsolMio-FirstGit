# HashTable 散列表

## 基本想法/一般想法
- 给定一表，表的大小为`TableSize`，每个关键字映射到表的0~TableSize-1范围内的某个值，并存放在适当的单元（内存中分好的区），其中映射称之为散列函数。
- 散列函数要求足够简单，并确保任意两个键不映射到同一值（若映射到同一值则称之为“冲突”）。但因为数据范围有限，完全避免不冲突不可能。
- 故需要确定一函数以处理冲突和确定散列表大小问题。

## 好的哈希函数
一般使用具有“代表性”的值计算以计算哈希值

- 对于字符串`String`：
此方法涉及到字符串中的所有字符ASCII码，使用函数$\sum_{i=0}^{KeySize-1}Key*37^i$。
使用Horner法则将此多象时展开，如：$h_k=k_0+37k_1+37^2k_2$，展开后为 $h_k=((k_2)*37+k_1)*37+k_0$ 。
使用Horner法则的原因：在编程中高次数的计算会导致数冗余（37\*37\*37\*...）
对于指数递增的高次多项式（如：$\sum_{i=0}^{KeySize-1}Key*37^i$）就要使用Horner法则，将公因式提取**以减小单次计算时的指数（此时指数化为1）**

```
public static in hash(String key, int tableSize){
    int hashVal = 0;
    for(int i=0;i<key.length;i++)
        hashVal+=37*hashVal+key.charAt(i);
    hashVal%=tableSize;
}
```


## 冲突处理
1. 对于任何的散列表，key所对应的hash值需要限制在表的大小之内（即 $hash=getHash(x)$ mod $tablesize$）。
2. 故无论多大的表，都会发生冲突。

## 冲突处理方式

**散列表创建时的大小通常为素数（只可被"1"和自身整除的数）**

- 先判断是否发生冲突
  `array[currentPos]!=null && !array[currentPos].element.equals(x)`返回`true`
- 通过

### 1. 分离链接表
- 即使用数组和链表的组合来实现，数组为链表类型数组，其每个单元的元素为链表。
- 通过hash值定位在数组中的位置，再将其放入至相应位置所拥有的链表中（hash值通过`int hash=obj.hashcode(); hash %=arrayLength; return hash;`方式获得）。
  - Tips: 因为受限于表的范围，需要将每个从对象获得的哈希值均映射到表中，故使用哈希值与表长之间求余数的方法以实现`hashValue % tableSize`。（**求余的特性：结果的范围限制于除数**）。
- 在发生冲突时只需将冲突的后值加入对应的链表中即可。

### 2. 线性探测法（非链式）
- 用函数定义为：$h(x)=hash(x)+f(i)$ , 其中$f(i)$ 为冲突解决方法。
	- 对于线性探测法，$f(i)=i$ ，其中 $i$ 为探测次数。
- 在发生冲突时，则线性查找下一个空闲地址，若有则插入。此方法会在表足够大时会导致计算时间加长，即使一定会有空闲的位置。
- 且在表相对较空的情况下，也会出现数据堆积在一块的现象。

### 3. 平方探测法（非链式）
- 用函数定义为：$h(x)=hash(x)+f(i)$，其中$f(i)$ 为冲突解决方法（与线性相似）。
	- 对于平方探测，$f(i)=i^2$ ，其中 $i$ 为探测次数。
- 可以使用递归的方式（自己定义自己，前者定义后者）重新定义$f(i)=i^2$ ：$f(i)=f(i-1)+2i-1$。
- 平方探测法和线性探测法一样，到达一定数量后会出现数据堆积在一起的情况。
- 在定义散列元素时加添了`isActive`属性，`boolean`类型，用于标记该元素的被删除情况（`false`）。

### 4. 双散列
- 用函数定义依然为：$h(x)=hash(x)+f(i)$，其中$f(i)$ 为冲突解决方法（与前两者相似）
	- 对于双散列，$f(i)=i*hash_2(x)$ ，将出现冲突的次数和第二个散列函数相乘
	- 通常使用：$hash_2(x)=R-(x$ $mod$ $R)$ ，$R$ 为小于 $tableSize$ 的素数
- 因函数中出现两个散列函数，故称双散列

### 5. 可扩散列
当出现值不足够放置于内存的情况时，则需要将

- 此散列的哈希值基于比特bit
- 此方法通过B树的特性：$O(log_{m/2}N)$（$N$为节点数，$M$为指定任意值）——当$M$越大时，树的深度增长越慢。
- 





