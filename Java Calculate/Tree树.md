# Tree树

## 基本概念
- 树本质上即是图
- 对于树的定义，使用了递归的方法，即用“树”本身定义自己（“树”->“树”->“树”->...）
- 在不是空集的情况下，树由根（root）的结点r和0个或多个非空子集（树）组成。
- 若有 $N$ 个结点，则有 $N-1$ 条边
- 同一“父亲”的子集之间均为兄弟（sibling）
- 没有子节点的结点成为“树叶”
- 从节点 $n_1$ 到 $n_k$ 的路径定义为节点为 $n_1, n_2, n_3, ...n_k$ 的序列，使得对于 $1<=i<k$ 的节点 $i$ 是 $i+1$ 的父亲，这条路径的长为路径上的条数 $k-1$  

## 树节点的申明定义
采用兄弟（sibling）之间互连的方式，以缓解因子树根节点的子集过多而显得臃肿和难以维护带来的问题。
CODE:
```
class TreeNode{
    Object element;
    TreeNode firstChild;// 指针，指向其第一个子集，若无则为null
    TreeNode nextSibling;// 指针，指向它的下一个兄弟，若无则为null
}
```

## 遍历
遍历分为 **先序遍历** 和 **后序遍历** 
- 先序遍历：节点在子节点被处理 前 被处理
- 后序遍历：节点在子节点被处理 后 被处理

## 二叉树 Binary Tree
此树的每个子节点不能有超过两个的子节点

最坏二叉树：每个节点只有一个子节点。

定义二叉树：
CODE：
```
class BinaryTree{
     Object element;
     BinaryTree left;
     BinaryTree right;
}
```

Tips:
1. 单目运算符：只有一个运算数，如`i++ !i`
2. 双目运算符：两个运算数，如`a+b, a!=b`
3. 三目运算符：三个运算数，如`i=a?b:c`

二叉树的应用：
1. 表达式：定义二叉树的叶子为运算数，其余的节点为运算符，使用中序遍历的方式读取整棵树。

## 查找树ADT-二叉查找树
- 定义：对于树中任意节点 $X$ ，其左子树的任一项均小于 $X$ ，其右子树的任意一项均大于 $X$ 。
- 普通二叉树在查找过程中需要按一定的顺序遍历左子树->右子树，机器时间耗费大。二叉查找树通过为树的基本单位“根 root-[左子树 left tree，右子树 right tree]”中的根及左右子树之间定义一关系，通过关系确定是遍历左子树亦或右子树，节省时间。

### 删除remove
- 对于树而言，删除是非常复杂的。
- 对于二叉查找树而言，删除指定的节点（非叶子）即替换指定节点——符合二叉查找树的定义（大于左子树任一项，小于右子树任一项）。
- 一般使用右子树最小的一项（即右子树的最左节点），p.s. 左子树的最大一项也ok（即左子树最右的一项）。

### Other详见CODE

## 