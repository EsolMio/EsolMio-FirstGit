# 选择排序
```
1 public class Selection 
2 { 
3      public static void sort(Comparable[] a) 
4      { // 将a[]按升序排列
5           int N = a.length; // 数组长度
6            for (int i = 0; i < N; i++) 
7            { // 将a[i]和a[i+1..N]中最小的元素交换
8                 int min = i; // 最小元素的索引
9                 for (int j = i+1; j < N; j++) 
10                     if (less(a[j], a[min])) min = j; 
11               exch(a, i, min); 
12           } 
13     } 
14 // less()、exch()、isSorted()和main()方法见“排序算法类模板”
15}
```
- 实现思路：大小传递性——如10行中的代码，在做的更小值后调换，意味比前面判断过的都小。遇见更小值则设为最小值。
- 需要两个for，第一个为确定初始判断主体（设为最小值），第二个为遍历后续元素与主体进行比较。若遇到更小值则将最小元素索引指向其，等到第二for结束后进行交换。
- 在无排序问题时依旧会进行遍历（第二for），浪费时间

# 插入排序
```
public class Insertion 
{ 
    public static void sort(Comparable[] a) 
    { // 将a[]按升序排列
        int N = a.length; 
        for (int i = 1; i < N; i++) 
        { // 将 a[i] 插入到 a[i-1]、a[i-2]、a[i-3]...之中
            for (int j = i; j > 0 && less(a[j], a[j-1]); j--)
                exch(a, j, j-1); 
        } 
    } 
// less()、exch()、isSorted()和main()方法见“排序算法类模板”
}
```
- 实现思路：偏序顺序为小到大，从后往前，设每次循环内最右为比较主体，若比挨边元素小则换位直到大于挨边元素。
- 为何不会有中间出校更小值情况（前为大，后遇到一更小值）？
  ```
  |0|2|7|3|4|5|6(key)|
  ```
  问题所述为此种情况。但需明确，每次第二for判断之时，前方的数据已排序，故不会出现问题情况。
- 问题：若比较主体比前数据集大（即比数据集第一个值大——从右向左）时，不需要继续检查，但此算法仍会继续检索下去，造成时间浪费

# 希尔排序
间隔排序，基于插入排序
```
public class Shell 
{ 
    public static void sort(Comparable[] a) 
        { // 将a[]按升序排列
        int N = a.length; 
        int h = 1; 
        while (h < N/3) h = 3*h + 1; // 1, 4, 13, 40, 121,     364, 1093, ... 
        while (h >= 1) 
        { // 将数组变为h有序
            for (int i = h; i < N; i++) 
            { // 将a[i]插入到a[i-h], a[i-2*h], a[i-3*h]... 之中
                for (int j = i; j >= h && less(a[j], a[j-h]); j -= h) 
                    exch(a, j, j-h); 
            } 
            h = h/3; 
        } 
  }
```
- 此算法的性能取决于间隔h，也取决于h之间的数学性质，如它们的公因子
- 此算法从最大间隔开始，从左向右依次间隔排序（相同间隔组成的新数组从右向左排序）
- 适合用于大型数组，且越大越好（相较于选择和插入）
- 间隔/递增序列一般使用：1, 4, 13, 40, ..., n*3+1
- Ex:令希尔排序打印出递增序列的每个元素所带来的比较次数和数组大小的比值。编写一个测试用例对随机 Double 数组进行希尔排序，验证该值是一个小常数，数组大小按照 10 的幂次递增，不小于 100。