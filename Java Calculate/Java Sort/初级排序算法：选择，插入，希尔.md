# 选择排序
```
1 public class Selection 
2 { 
3      public static void sort(Comparable[] a) 
4      { // 将a[]按升序排列
5           int N = a.length; // 数组长度
6            for (int i = 0; i < N; i++) 
7            { // 将a[i]和a[i+1..N]中最小的元素交换
8                 int min = i; // 最小元素的索引
9                 for (int j = i+1; j < N; j++) 
10                     if (less(a[j], a[min])) min = j; 
11               exch(a, i, min); 
12           } 
13     } 
14 // less()、exch()、isSorted()和main()方法见“排序算法类模板”
15}
```
实现思路：大小传递性——如10行中的代码，在做的更小值后调换，意味比前面判断过的都小。遇见更小值则设为最小值。
需要两个for，第一个为确定初始判断主体（设为最小值），第二个为遍历后续元素与主体进行比较。若遇到更小值则将最小元素索引指向其，等到第二for结束后进行交换。

# 插入排序
```
public class Insertion 
{ 
    public static void sort(Comparable[] a) 
    { // 将a[]按升序排列
        int N = a.length; 
        for (int i = 1; i < N; i++) 
        { // 将 a[i] 插入到 a[i-1]、a[i-2]、a[i-3]...之中
            for (int j = i; j > 0 && less(a[j], a[j-1]); j--)
                exch(a, j, j-1); 
        } 
    } 
// less()、exch()、isSorted()和main()方法见“排序算法类模板”
}
```
- 实现思路：偏序顺序为小到大，从后往前，设每次循环内最右为比较主体，若比挨边元素小则换位直到大于挨边元素。
- 为何不会有中间出校更小值情况（前为大，后遇到一更小值）？
  ```
  |0|2|7|3|4|5|6(key)|
  ```
  问题所述为此种情况。但需明确，每次第二for判断之时，前方的数据已排序，故不会出现问题情况。
- 问题：若比较主体比前数据集大（即比数据集第一个值大——从右向左）时，不需要继续检查，但此算法仍会继续检索下去，造成事件浪费