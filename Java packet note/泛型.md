# 泛型
## 什么是泛型
泛型即在为类实例化时所使用到的容器分配一个类型，此类型称为“泛型类型”。通过此方法创建一个对象以存储类的对象(.class)，可理解为将类型参数化。

## 使用泛型
1. 定义泛型：因泛型本质为类的对象的参数（“类型参数”），属于“类”的定义，即只能在申明类（亦可称为“容器”）（ `public class ...` ）和类方法（ `static ... function(){}//适当省略了部分定义` ）中申明。
   Example: 
    1. `public class TestClass<T>{ ... }`
    2. `public static <E> void xxx(){ ... } `
2. 使用泛型：
    1.  使泛型容器（定义泛型的类）实例化时，需要先使用尖括号表示法指定容器的类型：`TestClass<Integer> myInt=new TestClass<Integer>();`。
        此时容器/类实例化后其内部用泛型替代的类型参数均置换为`Integer`。
    2. ....
3. 参数的类型：参数类型为占位符，用于表示使用类型参数时的目的，根据惯例，用大写字母指示所定义的参数类型。以下为不同参数类型的用意：
	- E：元素（Element）
	- K：键（Key） 
	- N：数字（Number）
	- T：类型
	- V：值（Value）
	- 。。。
	
   每个参数的类型于其用意时直接对应的，注意区分及使用。
4. 构造器：泛型可用于构造器中，可自行选择是否在构造器中使用泛型
	1. 使用泛型：`new TestClass<Integer>`
	2. 不适用泛型时称为“原始类型”：`new TestClass()`，此时类型参数可理解为使用`Object`类型。 注意此时不执行类型检查，容易掷出`ClassCastException`。

5. 有界类型：
    - 将类型设置在一个上限内/将类型设定为某类型或某类型的子类型：
      `< T extends UpperBoundType >`
    - 将类型设置一个下限内/将类型设定为某类型或某类型的超类型：
      `< T super LowerBoundType >`

6. 泛型在`for()`中的特殊使用：
   - 先上例子：
     ```
     List<TestClass> textList=new ArrayList<TestClass>();
     ```










## 泛型的好处
1. 更强的类型检查，使用泛型后可避免可能掷出的`ClassCastException`所引发的时间浪费。
2. 消除类型转换